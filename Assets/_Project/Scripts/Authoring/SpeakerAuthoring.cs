using System.Collections;
using System.Collections.Generic;
using Unity.Entities;
using Unity.Transforms;
using UnityEngine;

using UnityEngine.Profiling;


public class GrainData
{
    public bool _Pooled = true;
    public bool _IsPlaying = false;
    public float[] _SampleData;
    public int _PlayheadIndex = 0;
    public float _PlayheadNormalised = 0;
    public int _SizeInSamples = -1;
    public int _DSPStartTime;

    public GrainData(int maxGrainSize)
    {
        _SampleData = new float[maxGrainSize];
    }
}

/// <summary>
//      Speaker components are the final stage of the EmitterSynth, bridging it to Unity's audio engine. 
//      Speakers are fed a queue of audio GrainPlaybackData, which is generated by GrainProcessors in the GrainSynth system.
//      At the SampleStartTime GrainPlaybackData samples are written to the AudioSource's buffer with OnAudioFilterRead.
/// <summary>
[RequireComponent(typeof(AudioSource))]
[RequireComponent(typeof(ConvertToEntity))]
public class SpeakerAuthoring : MonoBehaviour, IConvertGameObjectToEntity
{
    // Event to populate 
    public delegate void GrainEmitted(GrainData data, int currentDSPSample);
    public event GrainEmitted OnGrainEmitted;

    #region -------------------------- VARIABLES  
    protected EntityManager _EntityManager;
    protected Entity _SpeakerEntity;
    protected SpeakerComponent _SpeakerComponent;
    protected MeshRenderer _MeshRenderer;
    protected GrainData[] _GrainDataArray;  
    private AudioSource _AudioSource; 
    private int _SampleRate;

    public GrainSynth _GrainSynth;
    public int _SpeakerIndex = int.MaxValue;
    public float _AttachmentRadius = 1;
    readonly int _GrainPoolSize = 100;
    public int _PooledGrainCount = 0;
    private int _DebugTotalGrainsCreated = 0;
    readonly float _VolumeSmoothing = 4;
    private float _TargetVolume = 0;

    [SerializeField]
    private bool _Initialized = false;
    public bool _Registered = false;
    public bool _DebugLog = false;
    [SerializeField]
    private bool _IsActive = false;
    protected bool _GrainPoolReady = false;

    int ActiveGrainPlaybackDataCount { get { return _GrainDataArray.Length - _PooledGrainCount; } }
    public bool DedicatedToHost { get { return _StaticallyPairedEmitters.Count > 0; } }
    [HideInInspector]
    public List<GameObject> _StaticallyPairedEmitters = new List<GameObject>();

    #endregion

    public void Awake()
    {
        GetComponent<ConvertToEntity>().ConversionMode = ConvertToEntity.Mode.ConvertAndInjectGameObject;
    }

    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)
    {
        _EntityManager = World.DefaultGameObjectInjectionWorld.EntityManager;
        _MeshRenderer = gameObject.GetComponentInChildren<MeshRenderer>();
        _AudioSource = gameObject.GetComponent<AudioSource>();
        _SampleRate = AudioSettings.outputSampleRate;
        _SpeakerEntity = entity;
        _GrainSynth = FindObjectOfType<GrainSynth>();
        _GrainSynth.RegisterSpeaker(this);
        #if UNITY_EDITOR
                dstManager.SetName(_SpeakerEntity, "Speaker " + _SpeakerIndex + " (" + (DedicatedToHost ? "Dedicated" : "Dynamic") + ") ");
        #endif
        dstManager.AddComponentData(entity, new SpeakerComponent { _SpeakerIndex = _SpeakerIndex });

        if (!DedicatedToHost)
            dstManager.AddComponentData(entity, new PoolingComponent {
                _State = PooledState.Pooled,
                _AttachedHostCount = 0
            });

        //---   CREATE GRAIN DATA ARRAY - CURRENT MAXIMUM LENGTH SET TO ONE SECOND OF SAMPLES      
        _GrainDataArray = new GrainData[_GrainPoolSize];

        for (int i = 0; i < _GrainPoolSize; i++)
            _GrainDataArray[i] = CreateNewGrain();

        _PooledGrainCount = _GrainDataArray.Length;
        _AudioSource.rolloffMode = AudioRolloffMode.Custom;
        _AudioSource.maxDistance = 500;
        _GrainPoolReady = true;
        _Initialized = true;
    }

    public void AddEmitterLink(GameObject emitterGameObject)
    {
        _StaticallyPairedEmitters.Add(emitterGameObject);
    }
  
    public int RegisterAndGetIndex()
    {     
        GrainSynth.Instance.RegisterSpeaker(this);
        return _SpeakerIndex;
    }

    GrainData CreateNewGrain()
    {
        _DebugTotalGrainsCreated++;
        return new GrainData(_SampleRate);
    }

    public void Update()
    {
        if (!_Initialized)
            return;

        UpdateGrainObjectPool();

        if (_DebugLog)
            ReportGrainsDebug("");

        // TODO - dynamic speakers might be better defined as those spawned by the GrainSynth, not if they are the "dedicated to host"  
        #region ---   DYNAMIC EMITTER HOST ATTACHMENT
        if (!DedicatedToHost)
        {
            transform.position = _EntityManager.GetComponentData<Translation>(_SpeakerEntity).Value;
            _SpeakerComponent = _EntityManager.GetComponentData<SpeakerComponent>(_SpeakerEntity);
            _AttachmentRadius = _EntityManager.GetComponentData<PoolingComponent>(_SpeakerEntity)._AttachmentRadius;
            transform.localScale = Vector3.one * _AttachmentRadius;

            bool currentActiveState = _EntityManager.GetComponentData<PoolingComponent>(_SpeakerEntity)._State == PooledState.Active;
            //---   Reset playback grain data pool when the speaker disconnects
            if (_IsActive && !currentActiveState)
            {
                for (int i = 0; i < _GrainDataArray.Length; i++)
                {
                    _GrainDataArray[i]._Pooled = true;
                    _GrainDataArray[i]._IsPlaying = false;
                }
                _PooledGrainCount = _GrainDataArray.Length;
            }
            //---   SET MESH VISIBILITY AND VOLUME BASED ON CONNECTION TO EMITTER
            _TargetVolume = currentActiveState ? 1 : 0;
            _AudioSource.volume = Mathf.Lerp(_AudioSource.volume, _TargetVolume, Time.deltaTime * _VolumeSmoothing);
            if (_TargetVolume == 0 && _AudioSource.volume < .005f)
                _AudioSource.volume = 0;
            if (_MeshRenderer != null)
                _MeshRenderer.enabled = currentActiveState;

            _IsActive = currentActiveState;
        }
        #endregion
    }


    #region GRAIN DATA OBJECT POOL MANAGEMENT
    public GrainData GetEmptyGrainDataObject(out GrainData grainData)
    {
        grainData = null;
        if (_Initialized)
        {
            // If we're desperate, go through the GrainPool to check if any grains have finished
            if (_PooledGrainCount == 0 && !_GrainPoolReady)
                UpdateGrainObjectPool();
            // Get first pooled grain data object
            if (_PooledGrainCount > 0)
                for (int i = 0; i < _GrainDataArray.Length; i++)
                    if (_GrainDataArray[i]._Pooled)
                    {
                        grainData = _GrainDataArray[i];
                        return grainData;
                    }
        }
        return grainData;
    }
 
    public void UpdateGrainObjectPool()
    {
        _PooledGrainCount = 0;
        //---   Pool exhausted grain data objects for re-use.
        for (int i = 0; i < _GrainDataArray.Length; i++)
            if (!_GrainDataArray[i]._IsPlaying)
            {
                _GrainDataArray[i]._Pooled = true;
                _PooledGrainCount++;
            }

        _GrainPoolReady = true;
    }

    public void GrainDataAdded(GrainData grainData)
    {
        if (!_Initialized)
            return;
        _PooledGrainCount--;
        OnGrainEmitted?.Invoke(grainData, _GrainSynth._CurrentDSPSample);
    }
    #endregion



    void ReportGrainsDebug(string action)
    {
        //if (!_DebugLog)
        //    return;
                
        print(name + "---------------------------  " + action + "       A: " + ActiveGrainPlaybackDataCount + "  P: " + _PooledGrainCount + "      T: " + _DebugTotalGrainsCreated);        
    }


    // TODO -  ADD SAMPLE BUFFER RMS ANALYSIS FOR SPEAKER VISUAL MODULATION


    int _CurrentDSPSample;
    
    void OnAudioFilterRead(float[] data, int channels)
    {
        if (!_Initialized || _PooledGrainCount == _GrainPoolSize)
            return;
        
        GrainData grainData;
        _CurrentDSPSample = _GrainSynth._CurrentDSPSample;
        // For length of audio buffer, populate with grain samples, maintaining index over successive buffers
        for (int dataIndex = 0; dataIndex < data.Length; dataIndex += channels)
            for (int i = 0; i < _GrainDataArray.Length; i++) 
            {
                if (!_GrainDataArray[i]._IsPlaying)
                    continue;

                grainData = _GrainDataArray[i];
                //---   GRAIN DSP START INDEX REACHED = ADD SAMPLE
                if (_CurrentDSPSample >= grainData._DSPStartTime)
                    //--- GRAIN HAS REACHED THE END OF ITS PLAYHEAD = STOP PLAYBACK
                    if (grainData._PlayheadIndex >= grainData._SizeInSamples)
                    {
                        grainData._IsPlaying = false;
                        _GrainPoolReady = false;
                    }
                    else
                    {
                        //--- SHOULD ACCEPT MULTIPLE CHANNEL GRAINS/SPEAKERS. FRAMEWORK CURRENTLY MONO ONLY
                        for (int chan = 0; chan < channels; chan++)
                            data[dataIndex + chan] += grainData._SampleData[grainData._PlayheadIndex];
                        grainData._PlayheadIndex++;
                    }
            }
    }

    void OnDrawGizmos()
    {
        if (_IsActive)
        {
            if(_SpeakerIndex == 0)
                Gizmos.color = Color.blue;
            else
                Gizmos.color = Color.yellow;

            Gizmos.DrawWireSphere(transform.position, _AttachmentRadius);
        }
    }

    private void OnDestroy()
    {
        GrainSynth.Instance.DeRegisterSpeaker(this);
        DestroyEntity();
    }

    public void DestroyEntity()
    {
        //print("Speaker DestroyEntity");
        if (World.All.Count != 0 && _SpeakerEntity != null)
            _EntityManager.DestroyEntity(_SpeakerEntity);
    }

}
