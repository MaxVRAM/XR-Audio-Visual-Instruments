using System.Collections;
using System;
using System.Collections.Generic;
using Unity.Entities;
using Unity.Transforms;
using UnityEngine;

using UnityEngine.Profiling;
using Unity.VisualScripting;

public class GrainData
{
    public bool _Pooled = true;
    public bool _IsPlaying = false;
    public float[] _SampleData;
    public int _PlayheadIndex = 0;
    public float _PlayheadNormalised = 0;
    public int _SizeInSamples = -1;
    public int _DSPStartTime;

    public GrainData(int maxGrainSize)
    {
        _SampleData = new float[maxGrainSize];
    }
}

/// <summary>
//      Speaker components are the final stage of the EmitterSynth, bridging it to Unity's audio engine. 
//      Speakers are fed a queue of audio GrainPlaybackData, which is generated by GrainProcessors in the GrainSynth system.
//      At the SampleStartTime GrainPlaybackData samples are written to the AudioSource's buffer with OnAudioFilterRead.
/// <summary>
[RequireComponent(typeof(AudioSource))]
public class SpeakerAuthoring : MonoBehaviour, IConvertGameObjectToEntity
{
    // Event to populate 
    public delegate void GrainEmitted(GrainData data, int currentDSPSample);
    public event GrainEmitted OnGrainEmitted;

    #region -------------------------- VARIABLES  
    protected EntityManager _EntityManager;
    protected Entity _SpeakerEntity;
    protected MeshRenderer _MeshRenderer;
    protected GrainData[] _GrainDataArray;
    private AudioSource _AudioSource;
    private int _SampleRate;
    [SerializeField]
    protected int _SpeakerIndex = int.MaxValue;
    public int SpeakerIndex { get { return _SpeakerIndex; } }

    public float _AttachmentRadius = 1;
    readonly int _GrainPoolSize = 100;
    public int _PooledGrainCount = 0;
    private int _DebugTotalGrainsCreated = 0;
    readonly float _VolumeSmoothing = 4;
    private float _TargetVolume = 0;

    [SerializeField]
    private bool _Initialised = false;
    public bool _Registered = false;
    public bool _DebugLog = false;
    [SerializeField]
    private bool _DynamicSpeakerActive = false;
    protected bool _GrainPoolReady = false;

    int ActiveGrainPlaybackDataCount { get { return _GrainDataArray.Length - _PooledGrainCount; } }
    public bool _IsFixedSpeaker = false;
    public List<HostAuthoring> _FixedHosts = new List<HostAuthoring>();

    #endregion


    public void Awake()
    {
        Debug.Log($"Speaker {_SpeakerIndex} in AWAKE and about to check convert component");
        if (TryGetComponent(out ConvertToEntity converter))
        {
            Debug.Log($"Speaker {_SpeakerIndex} HAS convert component");
            converter.ConversionMode = ConvertToEntity.Mode.ConvertAndInjectGameObject;
        }
        else
            Debug.Log($"Speaker {_SpeakerIndex} DOES NOT HAVE convert component");
    }

    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)
    {
        Debug.Log($"Speaker {_SpeakerIndex} in CONVERT function. Fixed Speaker: {_IsFixedSpeaker}");
        _SpeakerEntity = entity;
        dstManager.AddComponentData(_SpeakerEntity, new SpeakerComponent { _SpeakerIndex = SpeakerIndex });

        #if UNITY_EDITOR
                dstManager.SetName(_SpeakerEntity, "Speaker " + _SpeakerIndex + " (Dynamic) ");
        #endif

        dstManager.AddComponentData(_SpeakerEntity, new PoolingComponent {
            _State = PooledState.Pooled,
            _AttachedHostCount = 0
        });

        _Initialised = true;
    }

    public void Start()
    {
        _SpeakerIndex = GrainSynth.Instance.RegisterSpeaker(this);
        _Registered = true;
        name = transform.parent.name + " - Speaker " + _SpeakerIndex;

        _SampleRate = AudioSettings.outputSampleRate;
        _MeshRenderer = gameObject.GetComponentInChildren<MeshRenderer>();
        _AudioSource = gameObject.GetComponent<AudioSource>();
        _AudioSource.rolloffMode = AudioRolloffMode.Custom;
        _AudioSource.maxDistance = 500;

        _EntityManager = World.DefaultGameObjectInjectionWorld.EntityManager;

        if (_IsFixedSpeaker)
        {
            _Initialised = true;

            if (_SpeakerEntity != null)
            {
                Debug.Log($"Speaker {_SpeakerIndex} in FIXED, but is associated with Entity. WHY!!");
            }
        }
        else
        {
            if (_SpeakerEntity == null)
            {
                Debug.Log($"Speaker {_SpeakerIndex} in DYNAMIC, but has no Entity. PLEASE KILL ME!!");
            }
        }


        _GrainDataArray = new GrainData[_GrainPoolSize];
        for (int i = 0; i < _GrainPoolSize; i++)
            _GrainDataArray[i] = CreateNewGrain();

        _PooledGrainCount = _GrainDataArray.Length;
        _GrainPoolReady = true;
    }

    public void AddEmitterHostLink(HostAuthoring host)
    {
        _FixedHosts.Add(host);
    }
 
    GrainData CreateNewGrain()
    {
        _DebugTotalGrainsCreated++;
        return new GrainData(_SampleRate);
    }

    public void Update()
    {
        if (!_Initialised)
            return;

        UpdateGrainObjectPool();

        // Clear lingering null hosts previously attached to this speaker
        _FixedHosts.RemoveAll(item => item == null);

        #region ---   DYNAMIC SPEAKER STUFF
        if (!_IsFixedSpeaker || _EntityManager == null)
        {
            SpeakerComponent speakerComponent = _EntityManager.GetComponentData<SpeakerComponent>(_SpeakerEntity);
            
            if (SpeakerIndex != speakerComponent._SpeakerIndex)
                _EntityManager.SetComponentData(_SpeakerEntity, new SpeakerComponent { _SpeakerIndex = SpeakerIndex });

            transform.position = _EntityManager.GetComponentData<Translation>(_SpeakerEntity).Value;
            _AttachmentRadius = _EntityManager.GetComponentData<PoolingComponent>(_SpeakerEntity)._AttachmentRadius;
            transform.localScale = Vector3.one * _AttachmentRadius;

            //---   Reset playback grain data pool when the speaker disconnects
            bool currentActiveState = _EntityManager.GetComponentData<PoolingComponent>(_SpeakerEntity)._State == PooledState.Active;
            if (_DynamicSpeakerActive && !currentActiveState)
            {
                for (int i = 0; i < _GrainDataArray.Length; i++)
                {
                    _GrainDataArray[i]._Pooled = true;
                    _GrainDataArray[i]._IsPlaying = false;
                }
                _PooledGrainCount = _GrainDataArray.Length;
            }
            //---   SET MESH VISIBILITY AND VOLUME BASED ON CONNECTION TO EMITTER
            _TargetVolume = currentActiveState ? 1 : 0;
            _AudioSource.volume = Mathf.Lerp(_AudioSource.volume, _TargetVolume, Time.deltaTime * _VolumeSmoothing);
            if (_TargetVolume == 0 && _AudioSource.volume < .005f)
                _AudioSource.volume = 0;
            if (_MeshRenderer != null)
                _MeshRenderer.enabled = currentActiveState;

            _DynamicSpeakerActive = currentActiveState;
        }
        #endregion
    }

    public int Reregister(int? index = null)
    {
        if (index.HasValue)
            _SpeakerIndex = index.Value;
        else
            _SpeakerIndex = GrainSynth.Instance.RegisterSpeaker(this);
        return SpeakerIndex;
    }


    #region GRAIN DATA OBJECT POOL MANAGEMENT

    public GrainData GetEmptyGrainDataObject(out GrainData grainData)
    {
        grainData = null;
        if (_Initialised)
        {
            // If we're desperate, go through the GrainPool to check if any grains have finished
            if (_PooledGrainCount == 0 && !_GrainPoolReady)
                UpdateGrainObjectPool();
            // Get first pooled grain data object
            if (_PooledGrainCount > 0)
                for (int i = 0; i < _GrainDataArray.Length; i++)
                    if (_GrainDataArray[i]._Pooled)
                    {
                        grainData = _GrainDataArray[i];
                        return grainData;
                    }
        }
        return grainData;
    }
 
    public void UpdateGrainObjectPool()
    {
        _PooledGrainCount = 0;
        //---   Move any exhausted grain data objects in the pool for re-use.
        for (int i = 0; i < _GrainDataArray.Length; i++)
            if (!_GrainDataArray[i]._IsPlaying)
            {
                _GrainDataArray[i]._Pooled = true;
                _PooledGrainCount++;
            }
        _GrainPoolReady = true;
    }

    public void GrainDataAdded(GrainData grainData)
    {
        if (!_Initialised)
            return;
        _PooledGrainCount--;
        OnGrainEmitted?.Invoke(grainData, GrainSynth.Instance._CurrentDSPSample);
    }

    #endregion


    // TODO -  ADD SAMPLE BUFFER RMS ANALYSIS FOR SPEAKER VISUAL MODULATION
    void OnAudioFilterRead(float[] data, int channels)
    {
        if (!_Initialised || _PooledGrainCount == _GrainPoolSize || _GrainDataArray == null)
            return;
        
        GrainData grainData;
        int _CurrentDSPSample = GrainSynth.Instance._CurrentDSPSample;
        // For length of audio buffer, populate with grain samples, maintaining index over successive buffers
        for (int dataIndex = 0; dataIndex < data.Length; dataIndex += channels)
            for (int i = 0; i < _GrainDataArray.Length; i++) 
            {
                if (!_GrainDataArray[i]._IsPlaying)
                    continue;

                grainData = _GrainDataArray[i];
                //---   GRAIN DSP START INDEX REACHED = ADD SAMPLE
                if (_CurrentDSPSample >= grainData._DSPStartTime)
                    //--- GRAIN HAS REACHED THE END OF ITS PLAYHEAD = STOP PLAYBACK
                    if (grainData._PlayheadIndex >= grainData._SizeInSamples)
                    {
                        grainData._IsPlaying = false;
                        _GrainPoolReady = false;
                    }
                    else
                    {
                        //--- SHOULD ACCEPT MULTIPLE CHANNEL GRAINS/SPEAKERS. FRAMEWORK CURRENTLY MONO ONLY
                        for (int chan = 0; chan < channels; chan++)
                            data[dataIndex + chan] += grainData._SampleData[grainData._PlayheadIndex];
                        grainData._PlayheadIndex++;
                    }
            }
    }

    private void OnDestroy()
    {
        GrainSynth.Instance.DeRegisterSpeaker(this);
        DestroyEntity();
    }

    public void DestroyEntity()
    {
        if (_IsFixedSpeaker || _SpeakerEntity == null)
            return;
        try
        {
            if (_EntityManager != null && World.All.Count != 0)
                _EntityManager.DestroyEntity(_SpeakerEntity);
        }
        catch (Exception ex) when (ex is NullReferenceException) { }
    }

}
